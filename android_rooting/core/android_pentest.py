#!/usr/bin/env python3
"""
Android Penetration Testing Integration Module
Integrates HackTricks methodologies and Kali Linux tools for comprehensive Android security testing

This module provides:
- ADB (Android Debug Bridge) advanced operations
- APK static and dynamic analysis
- Security vulnerability detection
- Kali NetHunter integration
- HackTricks methodology implementation

Compatible with: Kali Linux, NetHunter, Android 10+, ARM64
References: https://book.hacktricks.wiki/en/mobile-pentesting/android-app-pentesting
"""

import os
import sys
import subprocess
import json
import logging
import tempfile
import shutil
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union
import zipfile
import xml.etree.ElementTree as ET
from dataclasses import dataclass
import requests
import hashlib


@dataclass
class APKInfo:
    """APK information structure"""

    package_name: str
    version_name: str
    version_code: str
    min_sdk: str
    target_sdk: str
    permissions: List[str]
    activities: List[str]
    services: List[str]
    receivers: List[str]
    providers: List[str]
    is_debuggable: bool
    allows_backup: bool
    network_security_config: Optional[str]


class AndroidPentestFramework:
    """
    Comprehensive Android penetration testing framework

    Implements HackTricks methodologies and integrates Kali Linux tools
    for advanced Android security assessment.
    """

    def __init__(self, logger: Optional[logging.Logger] = None):
        self.logger = logger or logging.getLogger(__name__)
        self.adb_path = self._find_adb()
        self.temp_dir = tempfile.mkdtemp(prefix="android_pentest_")
        self.tools = self._initialize_tools()

    def _find_adb(self) -> str:
        """Find ADB binary in system"""
        adb_locations = [
            "/usr/bin/adb",
            "/usr/local/bin/adb",
            "/opt/android-sdk/platform-tools/adb",
            shutil.which("adb"),
        ]

        for location in adb_locations:
            if location and os.path.isfile(location) and os.access(location, os.X_OK):
                self.logger.info(f"Found ADB at: {location}")
                return location

        self.logger.warning("ADB not found in standard locations")
        return "adb"  # Hope it's in PATH

    def _initialize_tools(self) -> Dict[str, str]:
        """Initialize penetration testing tools"""
        tools = {}

        # Common penetration testing tools
        tool_names = [
            "aapt",
            "dex2jar",
            "jadx",
            "apktool",
            "jarsigner",
            "keytool",
            "zipalign",
            "objection",
            "frida",
            "drozer",
            "mobsf",
            "qark",
        ]

        for tool in tool_names:
            tool_path = shutil.which(tool)
            if tool_path:
                tools[tool] = tool_path
                self.logger.debug(f"Found {tool} at: {tool_path}")
            else:
                self.logger.debug(f"Tool {tool} not found")

        return tools

    def check_device_connection(self) -> Dict[str, Union[bool, List[str]]]:
        """Check ADB device connection and status"""
        self.logger.info("Checking device connection...")

        result = {
            "connected": False,
            "devices": [],
            "root_available": False,
            "usb_debugging": False,
        }

        try:
            # Check connected devices
            cmd_result = subprocess.run(
                [self.adb_path, "devices"], capture_output=True, text=True, timeout=10
            )

            if cmd_result.returncode == 0:
                lines = cmd_result.stdout.strip().split("\n")[1:]  # Skip header
                devices = []

                for line in lines:
                    if line.strip() and "\t" in line:
                        device_id, status = line.strip().split("\t")
                        devices.append({"id": device_id, "status": status})

                        if status == "device":
                            result["connected"] = True
                            result["usb_debugging"] = True

                result["devices"] = devices

                # Check root access if device connected
                if result["connected"]:
                    root_check = subprocess.run(
                        [self.adb_path, "shell", "su", "-c", "id"],
                        capture_output=True,
                        text=True,
                        timeout=5,
                    )
                    result["root_available"] = (
                        root_check.returncode == 0 and "uid=0" in root_check.stdout
                    )

        except Exception as e:
            self.logger.error(f"Device connection check failed: {e}")

        return result

    def extract_apk_from_device(self, package_name: str) -> Optional[str]:
        """
        Extract APK from device using HackTricks methodology

        Args:
            package_name: Package name to extract

        Returns:
            Path to extracted APK file
        """
        self.logger.info(f"Extracting APK for package: {package_name}")

        try:
            # List packages and find the target
            list_result = subprocess.run(
                [self.adb_path, "shell", "pm", "list", "packages", package_name],
                capture_output=True,
                text=True,
                timeout=10,
            )

            if package_name not in list_result.stdout:
                self.logger.error(f"Package {package_name} not found on device")
                return None

            # Get package path
            path_result = subprocess.run(
                [self.adb_path, "shell", "pm", "path", package_name],
                capture_output=True,
                text=True,
                timeout=10,
            )

            if path_result.returncode != 0:
                self.logger.error(f"Could not get path for package {package_name}")
                return None

            # Extract paths from output
            apk_paths = []
            for line in path_result.stdout.strip().split("\n"):
                if line.startswith("package:"):
                    apk_path = line.replace("package:", "")
                    apk_paths.append(apk_path)

            if not apk_paths:
                self.logger.error("No APK paths found")
                return None

            # Handle multiple APKs (splits)
            if len(apk_paths) > 1:
                self.logger.info(f"Found {len(apk_paths)} APK files (splits detected)")
                return self._handle_split_apks(package_name, apk_paths)
            else:
                # Single APK
                apk_path = apk_paths[0]
                local_path = os.path.join(self.temp_dir, f"{package_name}.apk")

                pull_result = subprocess.run(
                    [self.adb_path, "pull", apk_path, local_path],
                    capture_output=True,
                    text=True,
                    timeout=30,
                )

                if pull_result.returncode == 0:
                    self.logger.info(f"APK extracted to: {local_path}")
                    return local_path
                else:
                    self.logger.error(f"Failed to pull APK: {pull_result.stderr}")
                    return None

        except Exception as e:
            self.logger.error(f"APK extraction failed: {e}")
            return None

    def _handle_split_apks(
        self, package_name: str, apk_paths: List[str]
    ) -> Optional[str]:
        """Handle split APKs by merging them"""
        self.logger.info("Handling split APKs...")

        splits_dir = os.path.join(self.temp_dir, f"{package_name}_splits")
        os.makedirs(splits_dir, exist_ok=True)

        # Pull all splits
        for i, apk_path in enumerate(apk_paths):
            split_name = f"split_{i}.apk" if i > 0 else "base.apk"
            local_path = os.path.join(splits_dir, split_name)

            pull_result = subprocess.run(
                [self.adb_path, "pull", apk_path, local_path],
                capture_output=True,
                text=True,
                timeout=30,
            )

            if pull_result.returncode != 0:
                self.logger.error(f"Failed to pull split APK: {apk_path}")
                return None

        # Try to merge using APKEditor if available
        merged_apk = os.path.join(self.temp_dir, f"{package_name}_merged.apk")

        if "apkeditor" in self.tools:
            merge_cmd = [
                self.tools["apkeditor"],
                "m",
                "-i",
                splits_dir,
                "-o",
                merged_apk,
            ]
            merge_result = subprocess.run(
                merge_cmd, capture_output=True, text=True, timeout=60
            )

            if merge_result.returncode == 0:
                self.logger.info(f"APKs merged successfully: {merged_apk}")
                return merged_apk

        # Fallback: return base APK
        base_apk = os.path.join(splits_dir, "base.apk")
        if os.path.exists(base_apk):
            self.logger.warning("Using base APK only (splits not merged)")
            return base_apk

        return None

    def analyze_apk_static(self, apk_path: str) -> Dict:
        """
        Perform static analysis on APK following HackTricks methodology

        Args:
            apk_path: Path to APK file

        Returns:
            Static analysis results
        """
        self.logger.info(f"Starting static analysis of: {apk_path}")

        analysis_results = {
            "apk_info": None,
            "manifest_analysis": {},
            "security_issues": [],
            "interesting_strings": [],
            "firebase_urls": [],
            "api_keys": [],
            "hardcoded_secrets": [],
            "network_config": {},
            "certificate_info": {},
        }

        try:
            # Extract APK info
            analysis_results["apk_info"] = self._extract_apk_info(apk_path)

            # Analyze manifest
            analysis_results["manifest_analysis"] = self._analyze_manifest(apk_path)

            # Extract and analyze strings
            analysis_results["interesting_strings"] = self._extract_interesting_strings(
                apk_path
            )

            # Look for Firebase URLs
            analysis_results["firebase_urls"] = self._find_firebase_urls(apk_path)

            # Search for API keys and secrets
            analysis_results["api_keys"] = self._find_api_keys(apk_path)
            analysis_results["hardcoded_secrets"] = self._find_hardcoded_secrets(
                apk_path
            )

            # Analyze network security configuration
            analysis_results["network_config"] = self._analyze_network_config(apk_path)

            # Certificate analysis
            analysis_results["certificate_info"] = self._analyze_certificate(apk_path)

            # Identify security issues
            analysis_results["security_issues"] = self._identify_security_issues(
                analysis_results
            )

        except Exception as e:
            self.logger.error(f"Static analysis failed: {e}")

        return analysis_results

    def _extract_apk_info(self, apk_path: str) -> Optional[APKInfo]:
        """Extract basic APK information using aapt"""
        if "aapt" not in self.tools:
            self.logger.warning("aapt not available for APK analysis")
            return None

        try:
            cmd = [self.tools["aapt"], "dump", "badging", apk_path]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)

            if result.returncode != 0:
                self.logger.error(f"aapt failed: {result.stderr}")
                return None

            # Parse aapt output
            info = {}
            permissions = []
            activities = []
            services = []
            receivers = []

            for line in result.stdout.split("\n"):
                if line.startswith("package:"):
                    # Extract package info
                    parts = line.split()
                    for part in parts:
                        if part.startswith("name="):
                            info["package_name"] = part.split("=")[1].strip("'\"")
                        elif part.startswith("versionName="):
                            info["version_name"] = part.split("=")[1].strip("'\"")
                        elif part.startswith("versionCode="):
                            info["version_code"] = part.split("=")[1].strip("'\"")

                elif line.startswith("sdkVersion:"):
                    info["min_sdk"] = line.split(":")[1].strip().strip("'\"")
                elif line.startswith("targetSdkVersion:"):
                    info["target_sdk"] = line.split(":")[1].strip().strip("'\"")
                elif line.startswith("uses-permission:"):
                    perm = line.split("'")[1] if "'" in line else ""
                    if perm:
                        permissions.append(perm)
                elif line.startswith("launchable-activity:"):
                    activity = line.split("'")[1] if "'" in line else ""
                    if activity:
                        activities.append(activity)

            return APKInfo(
                package_name=info.get("package_name", ""),
                version_name=info.get("version_name", ""),
                version_code=info.get("version_code", ""),
                min_sdk=info.get("min_sdk", ""),
                target_sdk=info.get("target_sdk", ""),
                permissions=permissions,
                activities=activities,
                services=services,
                receivers=receivers,
                providers=[],
                is_debuggable=False,  # Will be determined from manifest
                allows_backup=True,  # Will be determined from manifest
                network_security_config=None,
            )

        except Exception as e:
            self.logger.error(f"APK info extraction failed: {e}")
            return None

    def _analyze_manifest(self, apk_path: str) -> Dict:
        """Analyze AndroidManifest.xml for security issues"""
        self.logger.debug("Analyzing AndroidManifest.xml")

        manifest_issues = {
            "debuggable": False,
            "backup_allowed": True,
            "network_security_config": None,
            "exported_components": [],
            "custom_permissions": [],
            "dangerous_permissions": [],
            "url_schemes": [],
            "tapjacking_vulnerable": [],
            "task_hijacking_vulnerable": [],
        }

        try:
            # Extract manifest using aapt
            if "aapt" in self.tools:
                cmd = [
                    self.tools["aapt"],
                    "dump",
                    "xmltree",
                    apk_path,
                    "AndroidManifest.xml",
                ]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)

                if result.returncode == 0:
                    manifest_content = result.stdout

                    # Check for debuggable
                    if (
                        "android:debuggable(0x0101000f)=(type 0x12)0xffffffff"
                        in manifest_content
                    ):
                        manifest_issues["debuggable"] = True

                    # Check for backup settings
                    if (
                        "android:allowBackup(0x01010280)=(type 0x12)0x0"
                        in manifest_content
                    ):
                        manifest_issues["backup_allowed"] = False

                    # Look for exported components
                    if (
                        "android:exported(0x01010010)=(type 0x12)0xffffffff"
                        in manifest_content
                    ):
                        manifest_issues["exported_components"].append(
                            "Found exported components"
                        )

        except Exception as e:
            self.logger.error(f"Manifest analysis failed: {e}")

        return manifest_issues

    def _extract_interesting_strings(self, apk_path: str) -> List[str]:
        """Extract interesting strings from APK"""
        interesting_strings = []

        try:
            # Use strings command on APK
            result = subprocess.run(
                ["strings", apk_path], capture_output=True, text=True, timeout=30
            )

            if result.returncode == 0:
                strings_list = result.stdout.split("\n")

                # Filter for interesting patterns
                patterns = [
                    "password",
                    "secret",
                    "key",
                    "token",
                    "api",
                    "http://",
                    "https://",
                    "ftp://",
                    "amazonaws.com",
                    "firebase",
                    "google",
                    "admin",
                    "root",
                    "debug",
                ]

                for string in strings_list:
                    string = string.strip()
                    if len(string) > 5:  # Ignore very short strings
                        for pattern in patterns:
                            if pattern.lower() in string.lower():
                                interesting_strings.append(string)
                                break

        except Exception as e:
            self.logger.error(f"String extraction failed: {e}")

        return list(set(interesting_strings))  # Remove duplicates

    def _find_firebase_urls(self, apk_path: str) -> List[str]:
        """Find Firebase URLs in APK"""
        firebase_urls = []

        try:
            result = subprocess.run(
                ["strings", apk_path], capture_output=True, text=True, timeout=30
            )

            if result.returncode == 0:
                for line in result.stdout.split("\n"):
                    if "firebaseio.com" in line or "firebase" in line.lower():
                        firebase_urls.append(line.strip())

        except Exception as e:
            self.logger.error(f"Firebase URL search failed: {e}")

        return firebase_urls

    def _find_api_keys(self, apk_path: str) -> List[str]:
        """Find potential API keys in APK"""
        api_keys = []

        try:
            result = subprocess.run(
                ["strings", apk_path], capture_output=True, text=True, timeout=30
            )

            if result.returncode == 0:
                import re

                # Common API key patterns
                patterns = [
                    r"AIza[0-9A-Za-z-_]{35}",  # Google API key
                    r"sk-[a-zA-Z0-9]{48}",  # OpenAI API key
                    r"xapp-[a-zA-Z0-9]{25}",  # Twitter API key
                    r"[a-zA-Z0-9]{32}",  # Generic 32-char key
                    r"[a-zA-Z0-9]{40}",  # Generic 40-char key
                ]

                for line in result.stdout.split("\n"):
                    for pattern in patterns:
                        matches = re.findall(pattern, line)
                        api_keys.extend(matches)

        except Exception as e:
            self.logger.error(f"API key search failed: {e}")

        return list(set(api_keys))

    def _find_hardcoded_secrets(self, apk_path: str) -> List[str]:
        """Find hardcoded secrets and credentials"""
        secrets = []

        try:
            result = subprocess.run(
                ["strings", apk_path], capture_output=True, text=True, timeout=30
            )

            if result.returncode == 0:
                # Look for common secret patterns
                secret_indicators = [
                    "password=",
                    "pwd=",
                    "pass=",
                    "secret=",
                    "key=",
                    "token=",
                    "admin",
                    "root",
                    "test123",
                    "credential",
                    "auth",
                ]

                for line in result.stdout.split("\n"):
                    line = line.strip()
                    for indicator in secret_indicators:
                        if indicator in line.lower() and len(line) > 10:
                            secrets.append(line)
                            break

        except Exception as e:
            self.logger.error(f"Secret search failed: {e}")

        return list(set(secrets))

    def _analyze_network_config(self, apk_path: str) -> Dict:
        """Analyze network security configuration"""
        network_config = {
            "custom_config": False,
            "allows_http": False,
            "certificate_pinning": False,
            "trust_user_certs": False,
        }

        try:
            # Extract network security config if present
            with zipfile.ZipFile(apk_path, "r") as apk_zip:
                file_list = apk_zip.namelist()

                # Look for network security config
                config_files = [f for f in file_list if "network_security_config" in f]

                if config_files:
                    network_config["custom_config"] = True

                    for config_file in config_files:
                        try:
                            config_content = apk_zip.read(config_file).decode("utf-8")

                            if 'cleartextTrafficPermitted="true"' in config_content:
                                network_config["allows_http"] = True

                            if "pin-set" in config_content:
                                network_config["certificate_pinning"] = True

                            if "trust-anchors" in config_content:
                                network_config["trust_user_certs"] = True

                        except Exception:
                            pass

        except Exception as e:
            self.logger.error(f"Network config analysis failed: {e}")

        return network_config

    def _analyze_certificate(self, apk_path: str) -> Dict:
        """Analyze APK certificate information"""
        cert_info = {"signed": False, "debug_signed": False, "certificate_details": {}}

        try:
            if "jarsigner" in self.tools:
                # Verify signature
                verify_cmd = [self.tools["jarsigner"], "-verify", "-verbose", apk_path]
                verify_result = subprocess.run(
                    verify_cmd, capture_output=True, text=True, timeout=30
                )

                if "jar verified" in verify_result.stdout:
                    cert_info["signed"] = True

                    # Check for debug certificate
                    if "CN=Android Debug" in verify_result.stdout:
                        cert_info["debug_signed"] = True

        except Exception as e:
            self.logger.error(f"Certificate analysis failed: {e}")

        return cert_info

    def _identify_security_issues(self, analysis_results: Dict) -> List[Dict]:
        """Identify security issues based on analysis results"""
        issues = []

        # Check for debuggable applications
        if analysis_results.get("manifest_analysis", {}).get("debuggable"):
            issues.append(
                {
                    "severity": "HIGH",
                    "category": "Application Security",
                    "issue": "Debuggable Application",
                    "description": "Application is set as debuggable, allowing debugging connections",
                    "remediation": 'Set android:debuggable="false" in production builds',
                }
            )

        # Check for backup allowed
        if analysis_results.get("manifest_analysis", {}).get("backup_allowed"):
            issues.append(
                {
                    "severity": "MEDIUM",
                    "category": "Data Protection",
                    "issue": "Backup Allowed",
                    "description": "Application allows backup via ADB, potentially exposing sensitive data",
                    "remediation": 'Set android:allowBackup="false" for sensitive applications',
                }
            )

        # Check for exported components
        exported_components = analysis_results.get("manifest_analysis", {}).get(
            "exported_components", []
        )
        if exported_components:
            issues.append(
                {
                    "severity": "MEDIUM",
                    "category": "Component Security",
                    "issue": "Exported Components",
                    "description": "Application has exported components that may be accessible to other apps",
                    "remediation": "Review exported components and ensure proper access controls",
                }
            )

        # Check for HTTP traffic allowed
        if analysis_results.get("network_config", {}).get("allows_http"):
            issues.append(
                {
                    "severity": "MEDIUM",
                    "category": "Network Security",
                    "issue": "HTTP Traffic Allowed",
                    "description": "Application allows unencrypted HTTP traffic",
                    "remediation": "Use HTTPS for all network communications",
                }
            )

        # Check for debug signing
        if analysis_results.get("certificate_info", {}).get("debug_signed"):
            issues.append(
                {
                    "severity": "HIGH",
                    "category": "Application Security",
                    "issue": "Debug Certificate",
                    "description": "Application is signed with debug certificate",
                    "remediation": "Sign with production certificate before release",
                }
            )

        # Check for hardcoded secrets
        secrets = analysis_results.get("hardcoded_secrets", [])
        if secrets:
            issues.append(
                {
                    "severity": "HIGH",
                    "category": "Sensitive Data",
                    "issue": "Hardcoded Secrets",
                    "description": f"Found {len(secrets)} potential hardcoded secrets",
                    "remediation": "Remove hardcoded credentials and use secure storage",
                }
            )

        return issues

    def perform_dynamic_analysis(self, package_name: str) -> Dict:
        """
        Perform dynamic analysis on running application

        Args:
            package_name: Target package name

        Returns:
            Dynamic analysis results
        """
        self.logger.info(f"Starting dynamic analysis of: {package_name}")

        dynamic_results = {
            "runtime_permissions": [],
            "network_traffic": [],
            "file_operations": [],
            "database_access": [],
            "shared_preferences": [],
            "logcat_analysis": [],
            "process_info": {},
        }

        try:
            # Check if app is running
            processes = self._get_app_processes(package_name)
            dynamic_results["process_info"] = processes

            if not processes:
                self.logger.warning(f"Application {package_name} is not running")
                return dynamic_results

            # Monitor logcat for the application
            dynamic_results["logcat_analysis"] = self._monitor_logcat(package_name)

            # Check runtime permissions
            dynamic_results["runtime_permissions"] = self._check_runtime_permissions(
                package_name
            )

            # Analyze data storage
            dynamic_results["shared_preferences"] = self._analyze_shared_preferences(
                package_name
            )
            dynamic_results["database_access"] = self._analyze_databases(package_name)
            dynamic_results["file_operations"] = self._analyze_file_operations(
                package_name
            )

        except Exception as e:
            self.logger.error(f"Dynamic analysis failed: {e}")

        return dynamic_results

    def _get_app_processes(self, package_name: str) -> Dict:
        """Get running processes for the application"""
        try:
            cmd = [self.adb_path, "shell", "ps", "|", "grep", package_name]
            result = subprocess.run(
                " ".join(cmd), shell=True, capture_output=True, text=True, timeout=10
            )

            processes = {}
            if result.returncode == 0 and result.stdout.strip():
                lines = result.stdout.strip().split("\n")
                for line in lines:
                    if package_name in line:
                        parts = line.split()
                        if len(parts) >= 2:
                            processes[parts[1]] = {  # PID
                                "user": parts[0] if len(parts) > 0 else "unknown",
                                "command": (
                                    " ".join(parts[8:])
                                    if len(parts) > 8
                                    else package_name
                                ),
                            }

            return processes

        except Exception as e:
            self.logger.error(f"Process check failed: {e}")
            return {}

    def _monitor_logcat(self, package_name: str, duration: int = 10) -> List[str]:
        """Monitor logcat for application logs"""
        logs = []

        try:
            # Clear existing logs
            subprocess.run([self.adb_path, "logcat", "-c"], timeout=5)

            # Monitor logs for specified duration
            cmd = [self.adb_path, "logcat", "-s", package_name, "-v", "time"]
            result = subprocess.run(
                cmd, capture_output=True, text=True, timeout=duration
            )

            if result.stdout:
                logs = result.stdout.split("\n")
                logs = [log.strip() for log in logs if log.strip()]

        except subprocess.TimeoutExpired:
            # Expected timeout
            pass
        except Exception as e:
            self.logger.error(f"Logcat monitoring failed: {e}")

        return logs

    def _check_runtime_permissions(self, package_name: str) -> List[str]:
        """Check runtime permissions for the application"""
        permissions = []

        try:
            cmd = [self.adb_path, "shell", "dumpsys", "package", package_name]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)

            if result.returncode == 0:
                in_permissions_section = False
                for line in result.stdout.split("\n"):
                    line = line.strip()

                    if "runtime permissions:" in line:
                        in_permissions_section = True
                        continue

                    if in_permissions_section:
                        if line.startswith("android.permission."):
                            permissions.append(line)
                        elif not line or line.startswith("User "):
                            in_permissions_section = False

        except Exception as e:
            self.logger.error(f"Runtime permissions check failed: {e}")

        return permissions

    def _analyze_shared_preferences(self, package_name: str) -> List[Dict]:
        """Analyze shared preferences files"""
        prefs_data = []

        try:
            # List shared preferences files
            prefs_path = f"/data/data/{package_name}/shared_prefs/"
            cmd = [self.adb_path, "shell", "ls", prefs_path]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)

            if result.returncode == 0:
                files = result.stdout.strip().split("\n")

                for file in files:
                    if file.endswith(".xml"):
                        file_path = f"{prefs_path}{file}"

                        # Try to read the file (requires root)
                        read_cmd = [
                            self.adb_path,
                            "shell",
                            "su",
                            "-c",
                            f"cat {file_path}",
                        ]
                        read_result = subprocess.run(
                            read_cmd, capture_output=True, text=True, timeout=5
                        )

                        if read_result.returncode == 0:
                            prefs_data.append(
                                {
                                    "file": file,
                                    "path": file_path,
                                    "content": read_result.stdout,
                                    "readable": True,
                                }
                            )
                        else:
                            prefs_data.append(
                                {
                                    "file": file,
                                    "path": file_path,
                                    "content": None,
                                    "readable": False,
                                }
                            )

        except Exception as e:
            self.logger.error(f"Shared preferences analysis failed: {e}")

        return prefs_data

    def _analyze_databases(self, package_name: str) -> List[Dict]:
        """Analyze SQLite databases"""
        db_data = []

        try:
            # List database files
            db_path = f"/data/data/{package_name}/databases/"
            cmd = [self.adb_path, "shell", "ls", db_path]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)

            if result.returncode == 0:
                files = result.stdout.strip().split("\n")

                for file in files:
                    if file.endswith(".db") or file.endswith(".sqlite"):
                        file_path = f"{db_path}{file}"

                        db_info = {
                            "file": file,
                            "path": file_path,
                            "tables": [],
                            "accessible": False,
                        }

                        # Try to access database (requires root)
                        tables_cmd = [
                            self.adb_path,
                            "shell",
                            "su",
                            "-c",
                            f"sqlite3 {file_path} '.tables'",
                        ]
                        tables_result = subprocess.run(
                            tables_cmd, capture_output=True, text=True, timeout=10
                        )

                        if tables_result.returncode == 0:
                            db_info["accessible"] = True
                            db_info["tables"] = tables_result.stdout.strip().split()

                        db_data.append(db_info)

        except Exception as e:
            self.logger.error(f"Database analysis failed: {e}")

        return db_data

    def _analyze_file_operations(self, package_name: str) -> List[Dict]:
        """Analyze file operations and storage"""
        file_info = []

        try:
            # Check internal storage
            internal_path = f"/data/data/{package_name}/"
            cmd = [self.adb_path, "shell", "ls", "-la", internal_path]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)

            if result.returncode == 0:
                file_info.append(
                    {
                        "location": "internal_storage",
                        "path": internal_path,
                        "contents": result.stdout,
                        "accessible": True,
                    }
                )

            # Check external storage
            external_paths = [
                f"/storage/emulated/0/Android/data/{package_name}/",
                f"/sdcard/Android/data/{package_name}/",
            ]

            for ext_path in external_paths:
                cmd = [self.adb_path, "shell", "ls", "-la", ext_path]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)

                if result.returncode == 0:
                    file_info.append(
                        {
                            "location": "external_storage",
                            "path": ext_path,
                            "contents": result.stdout,
                            "accessible": True,
                        }
                    )

        except Exception as e:
            self.logger.error(f"File operations analysis failed: {e}")

        return file_info

    def generate_pentest_report(
        self, package_name: str, static_results: Dict, dynamic_results: Dict
    ) -> str:
        """Generate comprehensive penetration testing report"""
        self.logger.info("Generating penetration testing report...")

        report_path = os.path.join(self.temp_dir, f"{package_name}_pentest_report.html")

        html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Android Penetration Testing Report - {package_name}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        .header {{ background-color: #2c3e50; color: white; padding: 20px; text-align: center; }}
        .section {{ margin: 20px 0; }}
        .issue-high {{ background-color: #e74c3c; color: white; padding: 10px; margin: 5px 0; }}
        .issue-medium {{ background-color: #f39c12; color: white; padding: 10px; margin: 5px 0; }}
        .issue-low {{ background-color: #f1c40f; color: black; padding: 10px; margin: 5px 0; }}
        .info-box {{ background-color: #ecf0f1; padding: 15px; border-left: 5px solid #3498db; }}
        table {{ border-collapse: collapse; width: 100%; }}
        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
        th {{ background-color: #f2f2f2; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>Android Penetration Testing Report</h1>
        <h2>Target: {package_name}</h2>
        <p>Generated by Android PenTest Framework</p>
    </div>
    
    <div class="section">
        <h2>Executive Summary</h2>
        <div class="info-box">
            <p>This report contains the results of a comprehensive security assessment of the Android application 
            <strong>{package_name}</strong> using automated static and dynamic analysis techniques.</p>
        </div>
    </div>
    
    <div class="section">
        <h2>Application Information</h2>
        {self._generate_app_info_html(static_results.get('apk_info'))}
    </div>
    
    <div class="section">
        <h2>Security Issues</h2>
        {self._generate_security_issues_html(static_results.get('security_issues', []))}
    </div>
    
    <div class="section">
        <h2>Static Analysis Results</h2>
        {self._generate_static_analysis_html(static_results)}
    </div>
    
    <div class="section">
        <h2>Dynamic Analysis Results</h2>
        {self._generate_dynamic_analysis_html(dynamic_results)}
    </div>
    
    <div class="section">
        <h2>Recommendations</h2>
        {self._generate_recommendations_html(static_results.get('security_issues', []))}
    </div>
    
    <div class="section">
        <h2>References</h2>
        <ul>
            <li><a href="https://book.hacktricks.wiki/en/mobile-pentesting/android-app-pentesting">HackTricks Android Pentesting</a></li>
            <li><a href="https://owasp.org/www-project-mobile-security-testing-guide/">OWASP Mobile Security Testing Guide</a></li>
            <li><a href="https://github.com/OWASP/owasp-mstg">OWASP MSTG</a></li>
        </ul>
    </div>
</body>
</html>
        """

        try:
            with open(report_path, "w", encoding="utf-8") as f:
                f.write(html_content)

            self.logger.info(f"Report generated: {report_path}")
            return report_path

        except Exception as e:
            self.logger.error(f"Report generation failed: {e}")
            return ""

    def _generate_app_info_html(self, apk_info: Optional[APKInfo]) -> str:
        """Generate HTML for application information"""
        if not apk_info:
            return "<p>Application information not available</p>"

        return f"""
        <table>
            <tr><th>Property</th><th>Value</th></tr>
            <tr><td>Package Name</td><td>{apk_info.package_name}</td></tr>
            <tr><td>Version Name</td><td>{apk_info.version_name}</td></tr>
            <tr><td>Version Code</td><td>{apk_info.version_code}</td></tr>
            <tr><td>Min SDK</td><td>{apk_info.min_sdk}</td></tr>
            <tr><td>Target SDK</td><td>{apk_info.target_sdk}</td></tr>
            <tr><td>Permissions</td><td>{len(apk_info.permissions)} permissions</td></tr>
            <tr><td>Debuggable</td><td>{'Yes' if apk_info.is_debuggable else 'No'}</td></tr>
            <tr><td>Backup Allowed</td><td>{'Yes' if apk_info.allows_backup else 'No'}</td></tr>
        </table>
        """

    def _generate_security_issues_html(self, issues: List[Dict]) -> str:
        """Generate HTML for security issues"""
        if not issues:
            return "<p>No security issues identified</p>"

        html = ""
        for issue in issues:
            severity_class = f"issue-{issue['severity'].lower()}"
            html += f"""
            <div class="{severity_class}">
                <h4>{issue['issue']} ({issue['severity']})</h4>
                <p><strong>Category:</strong> {issue['category']}</p>
                <p><strong>Description:</strong> {issue['description']}</p>
                <p><strong>Remediation:</strong> {issue['remediation']}</p>
            </div>
            """

        return html

    def _generate_static_analysis_html(self, static_results: Dict) -> str:
        """Generate HTML for static analysis results"""
        html = "<h3>Manifest Analysis</h3>"
        manifest = static_results.get("manifest_analysis", {})

        html += f"""
        <ul>
            <li>Debuggable: {'Yes' if manifest.get('debuggable') else 'No'}</li>
            <li>Backup Allowed: {'Yes' if manifest.get('backup_allowed') else 'No'}</li>
            <li>Exported Components: {len(manifest.get('exported_components', []))}</li>
        </ul>
        """

        html += "<h3>Interesting Strings</h3>"
        strings = static_results.get("interesting_strings", [])[
            :10
        ]  # Limit to first 10
        if strings:
            html += "<ul>"
            for string in strings:
                html += f"<li>{string}</li>"
            html += "</ul>"
        else:
            html += "<p>No interesting strings found</p>"

        return html

    def _generate_dynamic_analysis_html(self, dynamic_results: Dict) -> str:
        """Generate HTML for dynamic analysis results"""
        html = "<h3>Runtime Information</h3>"

        processes = dynamic_results.get("process_info", {})
        if processes:
            html += f"<p>Found {len(processes)} running processes</p>"
        else:
            html += "<p>Application not running during analysis</p>"

        html += "<h3>Runtime Permissions</h3>"
        permissions = dynamic_results.get("runtime_permissions", [])
        if permissions:
            html += "<ul>"
            for perm in permissions[:10]:  # Limit to first 10
                html += f"<li>{perm}</li>"
            html += "</ul>"
        else:
            html += "<p>No runtime permissions information available</p>"

        return html

    def _generate_recommendations_html(self, issues: List[Dict]) -> str:
        """Generate HTML for recommendations"""
        if not issues:
            return "<p>No specific recommendations at this time</p>"

        html = "<ul>"
        for issue in issues:
            html += (
                f"<li><strong>{issue['issue']}:</strong> {issue['remediation']}</li>"
            )
        html += "</ul>"

        return html

    def cleanup(self):
        """Clean up temporary files"""
        try:
            if os.path.exists(self.temp_dir):
                shutil.rmtree(self.temp_dir)
                self.logger.info("Temporary files cleaned up")
        except Exception as e:
            self.logger.error(f"Cleanup failed: {e}")


def main():
    """CLI interface for Android penetration testing framework"""
    import argparse

    parser = argparse.ArgumentParser(
        description="Android Penetration Testing Framework"
    )
    parser.add_argument(
        "action",
        choices=[
            "device-info",
            "extract-apk",
            "static-analysis",
            "dynamic-analysis",
            "full-pentest",
        ],
        help="Action to perform",
    )
    parser.add_argument("--package", help="Target package name")
    parser.add_argument("--apk", help="APK file path for static analysis")
    parser.add_argument("--output", help="Output directory for results")
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose logging")

    args = parser.parse_args()

    # Configure logging
    log_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(
        level=log_level, format="%(asctime)s - %(levelname)s - %(message)s"
    )

    framework = AndroidPentestFramework()

    try:
        if args.action == "device-info":
            device_info = framework.check_device_connection()
            print(json.dumps(device_info, indent=2))

        elif args.action == "extract-apk":
            if not args.package:
                print("Error: --package required for APK extraction")
                return 1

            apk_path = framework.extract_apk_from_device(args.package)
            if apk_path:
                print(f"APK extracted to: {apk_path}")
            else:
                print("APK extraction failed")
                return 1

        elif args.action == "static-analysis":
            if not args.apk:
                print("Error: --apk required for static analysis")
                return 1

            results = framework.analyze_apk_static(args.apk)
            print(json.dumps(results, indent=2, default=str))

        elif args.action == "dynamic-analysis":
            if not args.package:
                print("Error: --package required for dynamic analysis")
                return 1

            results = framework.perform_dynamic_analysis(args.package)
            print(json.dumps(results, indent=2, default=str))

        elif args.action == "full-pentest":
            if not args.package:
                print("Error: --package required for full pentest")
                return 1

            # Extract APK
            print("Extracting APK...")
            apk_path = framework.extract_apk_from_device(args.package)
            if not apk_path:
                print("APK extraction failed")
                return 1

            # Static analysis
            print("Performing static analysis...")
            static_results = framework.analyze_apk_static(apk_path)

            # Dynamic analysis
            print("Performing dynamic analysis...")
            dynamic_results = framework.perform_dynamic_analysis(args.package)

            # Generate report
            print("Generating report...")
            report_path = framework.generate_pentest_report(
                args.package, static_results, dynamic_results
            )

            if report_path:
                print(f"Penetration testing complete. Report: {report_path}")
            else:
                print("Report generation failed")
                return 1

    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
        return 1
    except Exception as e:
        print(f"Error: {e}")
        return 1
    finally:
        framework.cleanup()

    return 0


if __name__ == "__main__":
    sys.exit(main())

"""
References:
- HackTricks Android App Pentesting: https://book.hacktricks.wiki/en/mobile-pentesting/android-app-pentesting
- OWASP Mobile Security Testing Guide: https://owasp.org/www-project-mobile-security-testing-guide/
- Android Security Documentation: https://source.android.com/security/
- Kali NetHunter Project: https://gitlab.com/kalilinux/nethunter/build-scripts/kali-nethunter-project.git
- APK Tools: https://gitlab.alpinelinux.org/alpine/apk-tools.git
- Android Debug Bridge (ADB): https://developer.android.com/studio/command-line/adb
- Static Analysis Tools: aapt, dex2jar, jadx, apktool
- Dynamic Analysis Tools: Frida, Objection, Drozer
"""
