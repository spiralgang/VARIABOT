#!/usr/bin/env python3
"""
Error Bot Daemon
Production-grade error handling daemon for Android rooting operations

This daemon provides:
- Continuous error monitoring and adaptation
- Real-time process supervision
- Automatic recovery mechanisms
- GitHub integration for live code updates
- Persistent operation until goals achieved

Compatible with: Python 3.7+, Android 10+, Termux, Kali Linux
"""

import os
import sys
import time
import json
import signal
import logging
import asyncio
import argparse
import subprocess
import threading
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from enum import Enum
import psutil
import atexit


class DaemonStatus(Enum):
    """Daemon operational status"""
    STARTING = "starting"
    RUNNING = "running"
    MONITORING = "monitoring"
    ADAPTING = "adapting"
    STOPPED = "stopped"
    ERROR = "error"


class ErrorSeverity(Enum):
    """Error severity levels"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class ErrorEvent:
    """Error event data structure"""
    timestamp: datetime
    severity: ErrorSeverity
    source: str
    message: str
    context: Dict[str, Any]
    resolved: bool = False
    recovery_actions: List[str] = None


@dataclass
class DaemonConfig:
    """Error bot daemon configuration"""
    pid_file: str = "/tmp/error-bot.pid"
    log_file: str = "/sdcard/error-bot.log"
    error_log: str = "/sdcard/error-bot-errors.log"
    monitor_interval: float = 2.0
    adaptation_threshold: int = 5
    max_recovery_attempts: int = 10
    enable_github_integration: bool = False
    github_repo: Optional[str] = None
    github_token: Optional[str] = None


class ErrorBotDaemon:
    """
    Production-grade error handling daemon
    
    Provides continuous monitoring, error detection, and adaptive
    recovery for Android rooting and system operations.
    """

    def __init__(self, config: DaemonConfig):
        self.config = config
        self.status = DaemonStatus.STARTING
        self.running = False
        self.error_count = 0
        self.recovery_count = 0
        self.start_time = datetime.now()
        
        # Error tracking
        self.error_history: List[ErrorEvent] = []
        self.monitored_processes: Dict[int, Dict[str, Any]] = {}
        
        # Setup logging
        self.logger = self._setup_logging()
        
        # Signal handlers
        signal.signal(signal.SIGTERM, self._signal_handler)
        signal.signal(signal.SIGINT, self._signal_handler)
        
        # Cleanup on exit
        atexit.register(self._cleanup)

    def _setup_logging(self) -> logging.Logger:
        """Setup daemon logging"""
        logger = logging.getLogger("ErrorBotDaemon")
        logger.setLevel(logging.INFO)
        
        # File handler
        file_handler = logging.FileHandler(self.config.log_file)
        file_formatter = logging.Formatter(
            "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
        )
        file_handler.setFormatter(file_formatter)
        logger.addHandler(file_handler)
        
        # Console handler for foreground mode
        console_handler = logging.StreamHandler()
        console_formatter = logging.Formatter(
            "%(levelname)s - %(message)s"
        )
        console_handler.setFormatter(console_formatter)
        logger.addHandler(console_handler)
        
        return logger

    def _signal_handler(self, signum: int, frame) -> None:
        """Handle shutdown signals"""
        self.logger.info(f"Received signal {signum}, shutting down daemon...")
        self.running = False

    def _write_pid_file(self) -> None:
        """Write daemon PID to file"""
        try:
            with open(self.config.pid_file, "w") as f:
                f.write(str(os.getpid()))
            self.logger.info(f"PID file written: {self.config.pid_file}")
        except Exception as e:
            self.logger.error(f"Failed to write PID file: {e}")

    def _remove_pid_file(self) -> None:
        """Remove daemon PID file"""
        try:
            if os.path.exists(self.config.pid_file):
                os.unlink(self.config.pid_file)
                self.logger.info("PID file removed")
        except Exception as e:
            self.logger.error(f"Failed to remove PID file: {e}")

    def _cleanup(self) -> None:
        """Cleanup daemon resources"""
        self.logger.info("Performing daemon cleanup...")
        self._remove_pid_file()
        self._save_error_report()

    def start_daemon(self, foreground: bool = False) -> None:
        """Start the error bot daemon"""
        if not foreground:
            # Daemonize process
            try:
                # Fork first child
                if os.fork() > 0:
                    return  # Exit parent
            except OSError as e:
                self.logger.error(f"Fork failed: {e}")
                sys.exit(1)
            
            # Decouple from parent environment
            os.chdir("/")
            os.setsid()
            os.umask(0)
            
            # Fork second child
            try:
                if os.fork() > 0:
                    sys.exit(0)  # Exit first child
            except OSError as e:
                self.logger.error(f"Second fork failed: {e}")
                sys.exit(1)
            
            # Redirect standard file descriptors
            sys.stdout.flush()
            sys.stderr.flush()
            
            # Close stdin, stdout, stderr
            os.close(sys.stdin.fileno())
            os.close(sys.stdout.fileno())
            os.close(sys.stderr.fileno())
        
        # Write PID file
        self._write_pid_file()
        
        # Start main daemon loop
        self.running = True
        self.status = DaemonStatus.RUNNING
        self.logger.info("Error bot daemon started")
        
        try:
            self._main_loop()
        except Exception as e:
            self.logger.error(f"Daemon error: {e}")
            self.status = DaemonStatus.ERROR
        finally:
            self.status = DaemonStatus.STOPPED
            self.logger.info("Error bot daemon stopped")

    def _main_loop(self) -> None:
        """Main daemon monitoring loop"""
        while self.running:
            try:
                self.status = DaemonStatus.MONITORING
                
                # Monitor system processes
                self._monitor_processes()
                
                # Check for errors
                self._check_error_conditions()
                
                # Perform adaptations if needed
                if self.error_count >= self.config.adaptation_threshold:
                    self.status = DaemonStatus.ADAPTING
                    self._perform_error_adaptation()
                
                # Brief pause
                time.sleep(self.config.monitor_interval)
                
            except KeyboardInterrupt:
                break
            except Exception as e:
                self.logger.error(f"Main loop error: {e}")
                time.sleep(5)  # Longer pause on error

    def _monitor_processes(self) -> None:
        """Monitor running processes for rooting operations"""
        try:
            # Look for rooting-related processes
            rooting_keywords = [
                "magisk", "su", "supersu", "root", "android_root",
                "finalize_root", "kali_adapt", "termux_kali"
            ]
            
            current_processes = {}
            
            for proc in psutil.process_iter(['pid', 'name', 'cmdline', 'status']):
                try:
                    proc_info = proc.info
                    cmdline = " ".join(proc_info.get('cmdline', []))
                    
                    # Check if process is rooting-related
                    if any(keyword in cmdline.lower() or keyword in proc_info['name'].lower() 
                           for keyword in rooting_keywords):
                        
                        current_processes[proc_info['pid']] = {
                            'name': proc_info['name'],
                            'cmdline': cmdline,
                            'status': proc_info['status'],
                            'last_seen': datetime.now()
                        }
                        
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            # Check for process state changes
            for pid, proc_info in current_processes.items():
                if pid not in self.monitored_processes:
                    self.logger.info(f"New rooting process detected: {proc_info['name']} (PID: {pid})")
                
                self.monitored_processes[pid] = proc_info
            
            # Remove dead processes
            dead_pids = []
            for pid in self.monitored_processes:
                if pid not in current_processes:
                    dead_pids.append(pid)
            
            for pid in dead_pids:
                proc_info = self.monitored_processes[pid]
                self.logger.info(f"Rooting process ended: {proc_info['name']} (PID: {pid})")
                del self.monitored_processes[pid]
                
        except Exception as e:
            self.logger.error(f"Process monitoring error: {e}")

    def _check_error_conditions(self) -> None:
        """Check for error conditions in the system"""
        error_conditions = []
        
        try:
            # Check log files for errors
            error_conditions.extend(self._check_log_files())
            
            # Check system resources
            error_conditions.extend(self._check_system_resources())
            
            # Check rooting process status
            error_conditions.extend(self._check_rooting_status())
            
            # Process detected errors
            for condition in error_conditions:
                self._handle_error_condition(condition)
                
        except Exception as e:
            self.logger.error(f"Error condition checking failed: {e}")

    def _check_log_files(self) -> List[Dict[str, Any]]:
        """Check log files for error patterns"""
        errors = []
        
        log_files = [
            "/sdcard/root_adapt.log",
            "/sdcard/kali_adapt_bot.log",
            "/sdcard/finalize_root.log",
            "/var/log/syslog"
        ]
        
        error_patterns = [
            "error", "failed", "exception", "timeout", "denied",
            "permission", "access", "critical", "fatal"
        ]
        
        for log_file in log_files:
            if os.path.exists(log_file):
                try:
                    # Read last 100 lines
                    with open(log_file, "r") as f:
                        lines = f.readlines()[-100:]
                    
                    for line in lines:
                        line_lower = line.lower()
                        for pattern in error_patterns:
                            if pattern in line_lower:
                                errors.append({
                                    "source": "log_file",
                                    "file": log_file,
                                    "pattern": pattern,
                                    "line": line.strip(),
                                    "severity": self._determine_severity(line)
                                })
                                break
                                
                except Exception as e:
                    self.logger.debug(f"Error reading log file {log_file}: {e}")
        
        return errors

    def _check_system_resources(self) -> List[Dict[str, Any]]:
        """Check system resource conditions"""
        errors = []
        
        try:
            # Check memory usage
            memory = psutil.virtual_memory()
            if memory.percent > 90:
                errors.append({
                    "source": "system_resources",
                    "type": "memory",
                    "value": memory.percent,
                    "severity": ErrorSeverity.HIGH
                })
            
            # Check disk usage
            disk = psutil.disk_usage('/')
            if disk.percent > 95:
                errors.append({
                    "source": "system_resources",
                    "type": "disk",
                    "value": disk.percent,
                    "severity": ErrorSeverity.CRITICAL
                })
            
            # Check CPU usage
            cpu = psutil.cpu_percent(interval=1)
            if cpu > 95:
                errors.append({
                    "source": "system_resources",
                    "type": "cpu",
                    "value": cpu,
                    "severity": ErrorSeverity.MEDIUM
                })
                
        except Exception as e:
            self.logger.error(f"System resource check error: {e}")
        
        return errors

    def _check_rooting_status(self) -> List[Dict[str, Any]]:
        """Check rooting process status"""
        errors = []
        
        try:
            # Check if root detection fails
            root_detect_path = str(Path(__file__).parent / "root-detect")
            result = subprocess.run(
                ["python3", root_detect_path, "--json"],
                capture_output=True, text=True, timeout=10
            )
            
            if result.returncode == 0:
                root_data = json.loads(result.stdout)
                status = root_data.get("root_detection", {}).get("overall_status", "unknown")
                
                if status == "none":
                    errors.append({
                        "source": "rooting_status",
                        "type": "no_root_progress",
                        "status": status,
                        "severity": ErrorSeverity.MEDIUM
                    })
                    
        except Exception as e:
            errors.append({
                "source": "rooting_status",
                "type": "detection_failed",
                "error": str(e),
                "severity": ErrorSeverity.HIGH
            })
        
        return errors

    def _determine_severity(self, log_line: str) -> ErrorSeverity:
        """Determine error severity from log line"""
        line_lower = log_line.lower()
        
        if any(word in line_lower for word in ["critical", "fatal", "emergency"]):
            return ErrorSeverity.CRITICAL
        elif any(word in line_lower for word in ["error", "failed", "exception"]):
            return ErrorSeverity.HIGH
        elif any(word in line_lower for word in ["warning", "warn", "timeout"]):
            return ErrorSeverity.MEDIUM
        else:
            return ErrorSeverity.LOW

    def _handle_error_condition(self, condition: Dict[str, Any]) -> None:
        """Handle detected error condition"""
        self.error_count += 1
        
        error_event = ErrorEvent(
            timestamp=datetime.now(),
            severity=condition.get("severity", ErrorSeverity.MEDIUM),
            source=condition.get("source", "unknown"),
            message=json.dumps(condition),
            context=condition
        )
        
        self.error_history.append(error_event)
        self.logger.warning(f"Error detected: {error_event.source} - {error_event.severity.value}")
        
        # Immediate recovery actions for critical errors
        if error_event.severity == ErrorSeverity.CRITICAL:
            self._perform_immediate_recovery(error_event)

    def _perform_error_adaptation(self) -> None:
        """Perform adaptive error recovery"""
        self.logger.info("Performing error adaptation...")
        self.recovery_count += 1
        
        try:
            # Restart failed rooting processes
            self._restart_rooting_processes()
            
            # Clear system caches
            self._clear_system_caches()
            
            # Trigger Kali adaptation bot
            self._trigger_kali_adaptation()
            
            # Reset error count after successful adaptation
            self.error_count = 0
            
        except Exception as e:
            self.logger.error(f"Error adaptation failed: {e}")

    def _perform_immediate_recovery(self, error_event: ErrorEvent) -> None:
        """Perform immediate recovery for critical errors"""
        self.logger.critical(f"Performing immediate recovery for: {error_event.source}")
        
        try:
            # Kill hung processes
            if error_event.source == "rooting_status":
                self._kill_hung_processes()
            
            # Free up system resources
            if error_event.source == "system_resources":
                self._free_system_resources()
                
        except Exception as e:
            self.logger.error(f"Immediate recovery failed: {e}")

    def _restart_rooting_processes(self) -> None:
        """Restart failed rooting processes"""
        # Restart key rooting scripts
        rooting_scripts = [
            "/home/runner/work/VARIABOT/VARIABOT/android_rooting/scripts/finalize_root.sh",
            "/home/runner/work/VARIABOT/VARIABOT/android_rooting/bots/kali_adapt_bot.py"
        ]
        
        for script in rooting_scripts:
            if os.path.exists(script):
                try:
                    subprocess.Popen([script], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    self.logger.info(f"Restarted: {script}")
                except Exception as e:
                    self.logger.error(f"Failed to restart {script}: {e}")

    def _clear_system_caches(self) -> None:
        """Clear system caches to free resources"""
        try:
            # Clear package manager caches
            subprocess.run(["pkg", "clean"], capture_output=True, timeout=30)
            
            # Clear temporary files
            subprocess.run(["rm", "-rf", "/tmp/*"], capture_output=True, timeout=30)
            
            self.logger.info("System caches cleared")
        except Exception as e:
            self.logger.error(f"Cache clearing failed: {e}")

    def _trigger_kali_adaptation(self) -> None:
        """Trigger Kali adaptation bot"""
        try:
            kali_bot_script = "/home/runner/work/VARIABOT/VARIABOT/android_rooting/bots/kali_adapt_bot.py"
            if os.path.exists(kali_bot_script):
                subprocess.Popen([
                    "python3", kali_bot_script, 
                    "--max-attempts", "20"
                ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                self.logger.info("Kali adaptation bot triggered")
        except Exception as e:
            self.logger.error(f"Failed to trigger Kali adaptation: {e}")

    def _kill_hung_processes(self) -> None:
        """Kill hung rooting processes"""
        for pid in list(self.monitored_processes.keys()):
            try:
                proc = psutil.Process(pid)
                if proc.status() in [psutil.STATUS_ZOMBIE, psutil.STATUS_DEAD]:
                    proc.kill()
                    self.logger.info(f"Killed hung process: {pid}")
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                pass

    def _free_system_resources(self) -> None:
        """Free up critical system resources"""
        try:
            # Force garbage collection in Python processes
            subprocess.run(["python3", "-c", "import gc; gc.collect()"], timeout=10)
            
            # Drop system caches (if possible)
            subprocess.run(["sync"], timeout=10)
            
            self.logger.info("System resources freed")
        except Exception as e:
            self.logger.error(f"Resource freeing failed: {e}")

    def _save_error_report(self) -> None:
        """Save comprehensive error report"""
        try:
            report = {
                "daemon_info": {
                    "start_time": self.start_time.isoformat(),
                    "uptime_seconds": (datetime.now() - self.start_time).total_seconds(),
                    "error_count": self.error_count,
                    "recovery_count": self.recovery_count,
                    "status": self.status.value
                },
                "error_history": [asdict(error) for error in self.error_history[-50:]],  # Last 50 errors
                "monitored_processes": self.monitored_processes
            }
            
            with open(self.config.error_log, "w") as f:
                json.dump(report, f, indent=2, default=str)
                
            self.logger.info(f"Error report saved: {self.config.error_log}")
        except Exception as e:
            self.logger.error(f"Failed to save error report: {e}")

    def get_status(self) -> Dict[str, Any]:
        """Get daemon status information"""
        return {
            "status": self.status.value,
            "running": self.running,
            "uptime_seconds": (datetime.now() - self.start_time).total_seconds(),
            "error_count": self.error_count,
            "recovery_count": self.recovery_count,
            "monitored_processes": len(self.monitored_processes),
            "recent_errors": len([e for e in self.error_history if (datetime.now() - e.timestamp).seconds < 300])
        }


def main():
    """Main entry point for error bot daemon"""
    parser = argparse.ArgumentParser(description="Error Bot Daemon for Android Rooting")
    parser.add_argument("--daemon", action="store_true", help="Run in daemon mode")
    parser.add_argument("--foreground", action="store_true", help="Run in foreground mode")
    parser.add_argument("--stop", action="store_true", help="Stop running daemon")
    parser.add_argument("--status", action="store_true", help="Show daemon status")
    parser.add_argument("--pid-file", default="/tmp/error-bot.pid", help="PID file location")
    parser.add_argument("--log-file", default="/sdcard/error-bot.log", help="Log file location")
    parser.add_argument("--interval", type=float, default=2.0, help="Monitoring interval")
    
    args = parser.parse_args()
    
    config = DaemonConfig(
        pid_file=args.pid_file,
        log_file=args.log_file,
        monitor_interval=args.interval
    )
    
    if args.stop:
        # Stop daemon
        try:
            with open(config.pid_file, "r") as f:
                pid = int(f.read().strip())
            os.kill(pid, signal.SIGTERM)
            print(f"Daemon stopped (PID: {pid})")
        except FileNotFoundError:
            print("Daemon not running (PID file not found)")
        except ProcessLookupError:
            print("Daemon not running (process not found)")
        except Exception as e:
            print(f"Error stopping daemon: {e}")
        return
    
    if args.status:
        # Show status
        try:
            with open(config.pid_file, "r") as f:
                pid = int(f.read().strip())
            print(f"Daemon running (PID: {pid})")
            
            # Try to get detailed status if possible
            if os.path.exists(config.log_file):
                print(f"Log file: {config.log_file}")
                
        except FileNotFoundError:
            print("Daemon not running")
        except Exception as e:
            print(f"Error checking status: {e}")
        return
    
    # Start daemon
    daemon = ErrorBotDaemon(config)
    
    if args.daemon:
        daemon.start_daemon(foreground=False)
    else:
        daemon.start_daemon(foreground=True)


if __name__ == "__main__":
    main()

# References:
# - Internal: /reference_vault/PRODUCTION_GRADE_STANDARDS.md#error-handling
# - Internal: /reference_vault/linux_kali_android.md#bot-adaptation
# - External: Python Daemon Implementation — https://www.python.org/dev/peps/pep-3143/